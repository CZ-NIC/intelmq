#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""

"""
from __future__ import print_function, unicode_literals

import csv
import datetime
import io
import json
import os
import subprocess
import sys
import tempfile
import zipfile

import prettytable
import psycopg2
import psycopg2.extras
from termstyle import bold, green, inverted, red

import rt

if sys.version[0] == '2':
    input = raw_input

with open('/etc/intelmq/intelmqcli.conf') as conf_handle:
    CONFIG = json.load(conf_handle)
with open(os.path.expanduser('~/.intelmq/intelmqcli.conf')) as conf_handle:
    user_config = json.load(conf_handle)
for key, value in user_config.items():
    if key in CONFIG:
        CONFIG[key].update(value)
    else:
        CONFIG[key] = value
CON = psycopg2.connect(database=CONFIG['database']['database'],
                       user=CONFIG['database']['user'],
                       password=CONFIG['database']['password'],
                       host=CONFIG['database']['host'],
                       port=CONFIG['database']['port'],
                       sslmode=CONFIG['database']['sslmode'],
                       )
CUR = CON.cursor(cursor_factory=psycopg2.extras.RealDictCursor)
CON.autocommit = True

RT = rt.Rt(CONFIG['rt']['uri'], CONFIG['rt']['user'], CONFIG['rt']['password'])

QUERY_COUNT_ASN = """
SELECT
    COUNT(*) as count,
    COALESCE({conttab}.contacts, '') as contacts,
    string_agg(DISTINCT cast({evtab}."source.asn" as varchar), ', ') as asn,
    string_agg(DISTINCT {evtab}."classification.type", ', ') as classification,
    COALESCE({conttab}.contacts, cast({evtab}."source.asn" as varchar))
        as grouping
FROM {evtab}
LEFT OUTER JOIN as_contacts ON {evtab}."source.asn" = {conttab}.asnum
WHERE
    notify = TRUE AND
    {evtab}.rtir_report_id IS NULL AND
    {evtab}.rtir_incident_id IS NULL AND
    {evtab}.rtir_investigation_id IS NULL AND
    (
        {evtab}."source.geolocation.cc" LIKE '{cc}' OR
        {evtab}."source.fqdn" LIKE '{fqdn}'
    )
GROUP BY {conttab}.contacts, grouping;
""".format(evtab=CONFIG['database']['events_table'], cc=CONFIG['filter']['cc'],
           fqdn=CONFIG['filter']['fqdn'],
           conttab=CONFIG['database']['contacts_table'])
QUERY_BY_ASCONTACT = """
SELECT
    {evtab}.id,
    to_char({evtab}."time.source" at time zone 'UTC',
            'YYYY-MM-DD"T"HH24:MI:SSOF') as "time.source",
    {evtab}."source.ip",
    {evtab}."source.reverse_dns",
    {evtab}."source.fqdn",
    {evtab}."source.asn",
    {evtab}."source.url",
    {evtab}."feed.name",
    {evtab}."classification.identifier",
    {evtab}."classification.type"
FROM events
LEFT OUTER JOIN {conttab} ON {evtab}."source.asn" = {conttab}.asnum
WHERE
    notify = TRUE AND
    {evtab}.rtir_report_id IS NULL AND
    {evtab}.rtir_incident_id IS NULL AND
    {evtab}.rtir_investigation_id IS NULL AND
    {conttab}.contacts = '{{}}';
""".format(evtab=CONFIG['database']['events_table'],
           conttab=CONFIG['database']['contacts_table'])
QUERY_BY_ASNUM = """
SELECT
    {evtab}.id,
    to_char({evtab}."time.source" at time zone 'UTC',
            'YYYY-MM-DD"T"HH24:MI:SSOF') as "time.source",
    {evtab}."source.ip",
    {evtab}."source.reverse_dns",
    {evtab}."source.fqdn",
    {evtab}."source.asn",
    {evtab}."source.url",
    {evtab}."feed.name",
    {evtab}."classification.identifier",
    {evtab}."classification.type"
FROM events
LEFT OUTER JOIN {conttab} ON {evtab}."source.asn" = {conttab}.asnum
WHERE
    notify = TRUE AND
    {evtab}.rtir_report_id IS NULL AND
    {evtab}.rtir_incident_id IS NULL AND
    {evtab}.rtir_investigation_id IS NULL AND
    {evtab}."source.asn" = {{}};
""".format(evtab=CONFIG['database']['events_table'],
           conttab=CONFIG['database']['contacts_table'])
QUERY_SET_RTIRID = """
UPDATE {evtab} SET
    rtir_{{type}}_id = {{rtirid}},
    sent_at = LOCALTIMESTAMP
WHERE
    id = ANY('{{{{{{ids}}}}}}'::int[]);
""".format(evtab=CONFIG['database']['events_table'])
QUERY_UPDATE_CONTACT = """
UPDATE {conttab} SET
    contacts = '{{contacts}}'
WHERE
    asnum = ANY('{{{{{{asns}}}}}}'::int[]);
""".format(conttab=CONFIG['database']['contacts_table'])
QUERY_INSERT_CONTACT = """
INSERT INTO {conttab} (
    asnum, contacts, comment, unreliable
) VALUES (
    %s, %s, %s, FALSE
)
""".format(conttab=CONFIG['database']['contacts_table'])


def shrink_dict(d):
    keys = d[0].keys()
    empty = dict(zip(keys, [True]*len(keys)))
    for line in d:
        for key, value in line.items():
            if value is not None:
                empty[key] = False
    return [{k: v for k, v in dicti.items() if not empty[k]} for dicti in d]


def getTerminalHeight():
    return int(subprocess.check_output(['stty', 'size']).strip().split()[0])


def query_by_as(contact, show_table=False, requestor=None, automatic=False):
    if type(contact) is int:
        CUR.execute(QUERY_BY_ASNUM.format(contact))
        if requestor is None:
            requestor = ''
    else:
        CUR.execute(QUERY_BY_ASCONTACT.format(contact))
        if requestor is None:
            requestor = contact
    query = shrink_dict(CUR.fetchall())
    ids = list(str(row['id']) for row in query)

    subject = ('{date}: {count} incidents for your AS'
               ''.format(count=len(query),
                         date=datetime.datetime.now().strftime('%Y-%m-%d')))
    text = 'TODO: text'
    csvfile = io.StringIO()
    writer = csv.DictWriter(csvfile, fieldnames=sorted(query[0].keys()),
                            lineterminator='\n')
    writer.writeheader()
    writer.writerows(query)
    attachment_text = csvfile.getvalue()

    showed_text = ['='*100,
                   'To: {to}'.format(to=requestor),
                   'Subject: {subj}'.format(subj=subject),
                   '',
                   text,
                   '',
                   ]
    height = getTerminalHeight()-5
    if show_table:
        csvfile.seek(0)
        if len(query) > height:
            with tempfile.NamedTemporaryFile(mode='w+') as handle:
                handle.write('\n'.join(showed_text))
                handle.write('\n')
                handle.write(str(prettytable.from_csv(csvfile)))
                handle.seek(0)
                subprocess.call(['less', handle.name])
        else:
            print('\n'.join(showed_text), prettytable.from_csv(csvfile))
    else:
        if len(query) > height:
            print('\n'.join(showed_text))
            print('\n'.join(attachment_text.splitlines()[:height]))
            print('...')
        else:
            print('\n'.join(showed_text), attachment_text)
    print('-'*100)
    if automatic and requestor:
        answer = 's'
    else:
        if automatic:
            print(red('You need to set a valid requestor!'))
        answer = input(inverted('(b)ack, (s)end, show (t)able, change '
                                '(r)equestor or (q)uit? ')).strip()
    if answer == 'q':
        exit(0)
    elif answer == 'b':
        return
    elif answer == 't':
        query_by_as(contact, show_table=True, requestor=requestor)
        return
    elif answer == ('r'):
        answer = input(inverted('New requestor address: ')).strip()
        if len(answer) == 0:
            if type(contact) is int:
                requestor = ''
            else:
                requestor = contact
        else:
            requestor = answer
        query_by_as(contact, requestor=requestor)
        return
    elif answer != 's':
        print(red('Unknow command {!r}.'.format(answer)))
        query_by_as(contact, requestor=requestor)
        return

    report_id = RT.create_ticket(Queue='Incident Reports', Subject=subject,
                                 Requestors=requestor)
    if report_id == -1:
        print(red('Could not create Incident Report.'))
        return
    print(green('Created Incident Report {}.'.format(report_id)))
    CUR.execute(QUERY_SET_RTIRID.format(ids=','.join(ids), rtirid=report_id,
                                        type='report'))
    if True:  # TODO: implement zip config
        attachment = csvfile
        attachment.seek(0)
        filename = 'events.csv'
    else:
        attachment = io.BytesIO()
        ziphandle = zipfile.ZipFile(attachment, mode='w')
        ziphandle.writestr('events.csv', attachment_text)
        ziphandle.close()
        attachment.seek(0)
        filename = 'events.zip'
    response = RT.comment(report_id, files=[(filename, attachment)])
    if not response:
        print(red('Could not attach file.'))
        return

    incident_id = RT.create_ticket(Queue='Incidents', Subject=subject)
    if incident_id == -1:
        print(red('Could not create Incident.'))
        return
    print(green('Created Incident {}.'.format(incident_id)))
    if not RT.edit_link(report_id, 'MemberOf', incident_id):
        print(red('Could not link Incident to Incident Report.'))
        return
    CUR.execute(QUERY_SET_RTIRID.format(ids=','.join(ids), rtirid=incident_id,
                                        type='incident'))
    investigation_id = RT.create_ticket(Queue='Investigations',
                                        Subject=subject)
    if investigation_id == -1:
        print(red('Could not create Investigation.'))
        return
    print(green('Created Investigation {}.'.format(investigation_id)))
    if not RT.edit_link(incident_id, 'HasMember', investigation_id):
        print(red('Could not link Investigation to Incident.'))
        return
    CUR.execute(QUERY_SET_RTIRID.format(ids=','.join(ids),
                                        rtirid=investigation_id,
                                        type='investigation'))
    if not RT.edit_ticket(incident_id, Status='resolved'):
        print('Could not close incident {}.'.format(incident_id))

    if requestor != contact:
        asns = [str(row['source.asn']) for row in query]
        answer = input(inverted('Save recipient {!r} for ASNs {!s}? [Y/n]'
                                ''.format(requestor, ', '.join(asns)))).strip()
        if answer.lower() in ('', 'y', 'j'):
            CUR.execute(QUERY_UPDATE_CONTACT.format(asns=','.join(asns),
                                                    contacts=requestor))
            if CUR.rowcount != 1:
                for asn in asns:
                    user = os.environ['USER']
                    time = datetime.datetime.now().strftime('%c')
                    comment = 'Added by {user} @ {time}'.format(user=user,
                                                                time=time)
                    CUR.execute(QUERY_INSERT_CONTACT, (int(asn), requestor,
                                                       comment))


def count_by_asn():
    # TODO: Existing RT ids!
    CUR.execute(QUERY_COUNT_ASN)
    asn_count = CUR.fetchall()
    if not asn_count:
        print('No incidents!')
        exit(0)
    max_asn_length = max([len(row['asn']) for row in asn_count])
    max_contact_length = max([len(row['contacts']) for row in asn_count])
    print('='*100)
    print(bold("{id:>3} {count:3} {asn!s: <{asnlen}} {contacts!s: <{conlen}} "
               "{type!s}".format(id='id', count='n°', asn='ASNs', type='types',
                                 conlen=max_contact_length,
                                 asnlen=max_asn_length, contacts='contacts')))
    for number, row in enumerate(asn_count):
        print("{id:>3} {count:3} {asn!s: <{asnlen}} {contacts!s: <{conlen}} "
              "{type!s}".format(count=row['count'], asn=row['asn'],
                                asnlen=max_asn_length, id=number,
                                contacts=row['contacts'],
                                conlen=max_contact_length,
                                type=row['classification']))
    print('{} incidents for {} contacts.'
          ''.format(sum((row['count'] for row in asn_count)), len(asn_count)))
    return asn_count

if __name__ == '__main__':
    if not RT.login():
        print(red('Could not login to RT.'))
    try:
        while True:
            asn_count = count_by_asn()
            answer = input(inverted('detailed view by id, (a)utomatic '
                                    'sending, (q)uit? ')).strip()
            try:
                answer = int(answer)
            except ValueError:
                pass
            if answer == 'q':
                break
            elif answer == 'a':
                for item in asn_count:
                    if item['contacts']:
                        query_by_as(item['contacts'], automatic=True)
                    else:
                        query_by_as(int(item['asn']), automatic=True)
            elif type(answer) is int:
                if asn_count[answer]['contacts']:
                    query_by_as(asn_count[answer]['contacts'])
                else:
                    query_by_as(int(asn_count[answer]['asn']))

    except Exception as exc:
        if not isinstance(exc, SystemExit):
            raise
    finally:
        RT.logout()
