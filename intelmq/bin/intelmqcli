#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
The pprint argument `compact` is only available on Python 3.
"""
from __future__ import print_function, unicode_literals

import csv
import datetime
import io
import os
import prettytable
import subprocess
import sys
import tempfile
import zipfile

import intelmq.lib.utils as utils
import psycopg2
import psycopg2.extras
from intelmq import INTELMQCLI_CONF_FILE
from termstyle import bold, inverted, green, red

import rt


if sys.version[0] == '2':
    input = raw_input

CONFIG = utils.load_configuration(INTELMQCLI_CONF_FILE)
CON = psycopg2.connect(database=CONFIG['database']['database'],
                       user=CONFIG['database']['user'],
                       password=CONFIG['database']['password'],
                       host=CONFIG['database']['host'],
                       port=CONFIG['database']['port'],
                       sslmode=CONFIG['database']['sslmode'],
                       )
CUR = CON.cursor(cursor_factory=psycopg2.extras.RealDictCursor)
CON.autocommit = True

RT = rt.Rt(CONFIG['rt']['uri'], CONFIG['rt']['user'], CONFIG['rt']['password'])

logger = utils.log('intelmqcli', log_level=CONFIG['log_level'])

QUERY_COUNT_ASN = """
SELECT
    COUNT(*) as count,
    COALESCE({conttab}.contacts, '') as contacts,
    string_agg(DISTINCT cast({evtab}."source.asn" as varchar), ', ') as asn,
    string_agg(DISTINCT {evtab}."classification.type", ', ') as classification,
    COALESCE({conttab}.contacts, cast({evtab}."source.asn" as varchar))
        as grouping
FROM {evtab}
LEFT OUTER JOIN as_contacts ON {evtab}."source.asn" = {conttab}.asnum
WHERE
    notify = TRUE AND
    {evtab}.rtir_report_id IS NULL AND
    {evtab}.rtir_incident_id IS NULL AND
    {evtab}.rtir_investigation_id IS NULL AND
    (
        {evtab}."source.geolocation.cc" LIKE '{cc}' OR
        {evtab}."source.fqdn" LIKE '{fqdn}'
    )
GROUP BY {conttab}.contacts, grouping;
""".format(evtab=CONFIG['database']['events_table'], cc=CONFIG['filter']['cc'],
           fqdn=CONFIG['filter']['fqdn'],
           conttab=CONFIG['database']['contacts_table'])
QUERY_BY_ASCONTACT = """
SELECT
    {evtab}.id,
    to_char({evtab}."time.source" at time zone 'UTC',
            'YYYY-MM-DD"T"HH24:MI:SSOF') as "time.source",
    {evtab}."source.ip",
    {evtab}."source.reverse_dns",
    {evtab}."source.fqdn",
    {evtab}."source.asn",
    {evtab}."source.url",
    {evtab}."feed.name",
    {evtab}."classification.type"
FROM events
LEFT OUTER JOIN {conttab} ON {evtab}."source.asn" = {conttab}.asnum
WHERE
    notify = TRUE AND
    {evtab}.rtir_report_id IS NULL AND
    {evtab}.rtir_incident_id IS NULL AND
    {evtab}.rtir_investigation_id IS NULL AND
    {conttab}.contacts = '{{}}';
""".format(evtab=CONFIG['database']['events_table'],
           conttab=CONFIG['database']['contacts_table'])
QUERY_BY_ASNUM = """
SELECT
    {evtab}.id,
    to_char({evtab}."time.source" at time zone 'UTC',
            'YYYY-MM-DD"T"HH24:MI:SSOF') as "time.source",
    {evtab}."source.ip",
    {evtab}."source.reverse_dns",
    {evtab}."source.fqdn",
    {evtab}."source.asn",
    {evtab}."source.url",
    {evtab}."feed.name",
    {evtab}."classification.type"
FROM events
LEFT OUTER JOIN {conttab} ON {evtab}."source.asn" = {conttab}.asnum
WHERE
    notify = TRUE AND
    {evtab}.rtir_report_id IS NULL AND
    {evtab}.rtir_incident_id IS NULL AND
    {evtab}.rtir_investigation_id IS NULL AND
    {evtab}."source.asn" = {{}};
""".format(evtab=CONFIG['database']['events_table'],
           conttab=CONFIG['database']['contacts_table'])
QUERY_SET_RTIRID = """
UPDATE {evtab} SET
    rtir_{{type}}_id = {{rtirid}}
WHERE
    id = ANY('{{{{{{ids}}}}}}'::int[]);
""".format(evtab=CONFIG['database']['events_table'])
QUERY_UPDATE_CONTACT = """
UPDATE {conttab} SET
    contacts = '{{contacts}}'
WHERE
    asnum = ANY('{{{{{{asns}}}}}}'::int[]);
""".format(conttab=CONFIG['database']['contacts_table'])
QUERY_INSERT_CONTACT = """
INSERT INTO {conttab} (
    asnum, contacts, comment, unreliable
) VALUES (
    %s, %s, %s, FALSE
)
""".format(conttab=CONFIG['database']['contacts_table'])


def shrink_dict(d):
    keys = d[0].keys()
    empty = dict(zip(keys, [True]*len(keys)))
    for line in d:
        for key, value in line.items():
            if value is not None:
                empty[key] = False
    return [{k: v for k, v in dicti.items() if not empty[k]} for dicti in d]


def getTerminalHeight():
    return int(subprocess.check_output(['stty', 'size']).strip().split()[0])


def query_by_as(contact, show_table=False, requestor=None):
    if type(contact) is int:
        CUR.execute(QUERY_BY_ASNUM.format(contact))
        if requestor is None:
            requestor = ''
    else:
        CUR.execute(QUERY_BY_ASCONTACT.format(contact))
        if requestor is None:
            requestor = contact
    query = shrink_dict(CUR.fetchall())
    ids = list(str(row['id']) for row in query)

    subject = ('{date}: {count} incidents for your AS'
               ''.format(count=len(query),
                         date=datetime.datetime.now().strftime('%Y-%m-%d')))
    text = 'TODO: text'
    csvfile = io.StringIO()
    writer = csv.DictWriter(csvfile, fieldnames=sorted(query[0].keys()),
                            lineterminator='\n')
    writer.writeheader()
    writer.writerows(query)
    attachment_text = csvfile.getvalue()

    showed_text = ['='*100,
                   'To: {to}'.format(to=requestor),
                   'Subject: {subj}'.format(subj=subject),
                   '',
                   text,
                   '',
                   ]
    height = getTerminalHeight()-5
    if show_table:
        csvfile.seek(0)
        if len(query) > height:
            with tempfile.NamedTemporaryFile(mode='w+') as handle:
                handle.write('\n'.join(showed_text))
                handle.write('\n')
                handle.write(str(prettytable.from_csv(csvfile)))
                handle.seek(0)
                subprocess.call(['less', handle.name])
        else:
            print('\n'.join(showed_text), prettytable.from_csv(csvfile))
    else:
        if len(query) > height:
            print('\n'.join(showed_text))
            print('\n'.join(attachment_text.splitlines()[:height]))
            print('...')
        else:
            print('\n'.join(showed_text), attachment_text)
    print('-'*100)
    answer = input(inverted('(b)ack, (s)end, show (t)able, change (r)equestor '
                            'or (q)uit? ')).strip()
    if answer == 'q':
        exit(0)
    elif answer == 'b':
        return
    elif answer == 't':
        query_by_as(contact, show_table=True, requestor=requestor)
        return
    elif answer.startswith('r'):
        if len(answer) == 1:
            if type(contact) is int:
                requestor = ''
            else:
                requestor = contact
        elif answer[1:].strip().startswith('+'):
            requestor = requestor+','+answer[1:].strip()[1:]
        elif answer[1:].strip().startswith('-'):
            requestor = requestor.replace(answer[1:].strip()[1:], '')
        else:
            requestor = answer[1:].strip()
        query_by_as(contact, requestor=requestor.strip(','))
        return
    elif answer != 's':
        print(red('Unknow command {!r}.'.format(answer)))
        query_by_as(contact, requestor=requestor)
        return

    report_id = RT.create_ticket(Queue='Incident Reports', Subject=subject,
                                 Requestors=requestor)
    if report_id == -1:
        logger.error(red('Could not create Incident Report.'))
        return
    logger.info(green('Created Incident Report {}.'.format(report_id)))
    CUR.execute(QUERY_SET_RTIRID.format(ids=','.join(ids), rtirid=report_id,
                                        type='report'))
    attachment = io.BytesIO()
    ziphandle = zipfile.ZipFile(attachment, mode='w')
    ziphandle.writestr('events.csv', attachment_text)
    ziphandle.close()
    attachment.seek(0)
    response = RT.comment(report_id, files=[('events.zip', attachment)])
    if not response:
        logger.exception(red('Could not attach file.'))
        return

    incident_id = RT.create_ticket(Queue='Incidents', Subject=subject)
    if incident_id == -1:
        logger.error(red('Could not create Incident.'))
        return
    logger.info(green('Created Incident {}.'.format(incident_id)))
    if not RT.edit_link(report_id, 'MemberOf', incident_id):
        logger.error(red('Could not link Incident to Incident Report.'))
        return
    CUR.execute(QUERY_SET_RTIRID.format(ids=','.join(ids), rtirid=incident_id,
                                        type='incident'))
    investigation_id = RT.create_ticket(Queue='Investigations',
                                        Subject=subject)
    if investigation_id == -1:
        logger.error(red('Could not create Investigation.'))
        return
    logger.info(green('Created Investigation {}.'.format(investigation_id)))
    if not RT.edit_link(incident_id, 'HasMember', investigation_id):
        logger.error(red('Could not link Investigation to Incident.'))
        return
    CUR.execute(QUERY_SET_RTIRID.format(ids=','.join(ids),
                                        rtirid=investigation_id,
                                        type='investigation'))
    if not RT.edit_ticket(incident_id, Status='resolved'):
        logger.error('Could not close incident {}.'.format(incident_id))

    if requestor != contact:
        asns = [str(row['source.asn']) for row in query]
        answer = input(inverted('Save recipient {!r} for ASNs {!s}? [Y/n]'
                                ''.format(requestor, ', '.join(asns)))).strip()
        if answer.lower() in ('', 'y', 'j'):
            CUR.execute(QUERY_UPDATE_CONTACT.format(asns=','.join(asns),
                                                    contacts=requestor))
            if CUR.rowcount != 1:
                for asn in asns:
                    user = os.environ['USER']
                    time = datetime.datetime.now().strftime('%c')
                    comment = 'Added by {user} @ {time}'.format(user=user,
                                                                time=time)
                    CUR.execute(QUERY_INSERT_CONTACT, (int(asn), requestor,
                                                       comment))


def count_by_asn():
    # TODO: Existing RT ids!
    CUR.execute(QUERY_COUNT_ASN)
    asn_count = CUR.fetchall()
    max_asn_length = max([len(row['asn']) for row in asn_count])
    max_contact_length = max([len(row['contacts']) for row in asn_count])
    print('='*100)
    print(bold("{id:>3} {count:3} {asn!s: <{asnlen}} {contacts!s: <{conlen}} "
               "{type!s}".format(id='id', count='n°', asn='ASNs', type='types',
                                 conlen=max_contact_length,
                                 asnlen=max_asn_length, contacts='contacts')))
    for number, row in enumerate(asn_count):
        print("{id:>3} {count:3} {asn!s: <{asnlen}} {contacts!s: <{conlen}} "
              "{type!s}".format(count=row['count'], asn=row['asn'],
                                asnlen=max_asn_length, id=number,
                                contacts=row['contacts'],
                                conlen=max_contact_length,
                                type=row['classification']))
    print('{} incidents for {} contacts.'
          ''.format(sum((row['count'] for row in asn_count)), len(asn_count)))
    return asn_count

if __name__ == '__main__':
    if not RT.login():
        logger.error(red('Could not login to RT.'))
    try:
        while True:
            asn_count = count_by_asn()
            answer = input(inverted('detailed view by id, (a)utomatic '
                                    'sending, (q)uit? ')).strip()
            try:
                answer = int(answer)
            except ValueError:
                pass
            if answer == 'q':
                break
            elif answer == 'a':
                raise NotImplementedError
                for count, contacts, asn, classtype in asn_count:
                    query_by_as(contacts)
            elif type(answer) is int:
                if asn_count[answer]['contacts']:
                    query_by_as(asn_count[answer]['contacts'])
                else:
                    query_by_as(int(asn_count[answer]['asn']))

    except Exception as exc:
        if not isinstance(exc, SystemExit):
            logger.exception('')
    finally:
        RT.logout()
