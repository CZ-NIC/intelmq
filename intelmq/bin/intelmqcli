#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
The pprint argument `compact` is only available on Python 3.
"""
from __future__ import print_function, unicode_literals

import csv
import datetime
import io
import prettytable
import pprint
import sys
import zipfile

import intelmq.lib.utils as utils
import psycopg2
import psycopg2.extras
from intelmq import INTELMQCLI_CONF_FILE
from termstyle import bold, inverted, green, red

import rt


if sys.version[0] == '2':
    input = raw_input

CONFIG = utils.load_configuration(INTELMQCLI_CONF_FILE)
DBTABLE = CONFIG['database']['events_table']
CON = psycopg2.connect(database=CONFIG['database']['database'],
                       user=CONFIG['database']['user'],
                       password=CONFIG['database']['password'],
                       host=CONFIG['database']['host'],
                       port=CONFIG['database']['port'],
                       sslmode=CONFIG['database']['sslmode'],
                       )
CUR = CON.cursor(cursor_factory=psycopg2.extras.RealDictCursor)
CON.autocommit = True

RT = rt.Rt(CONFIG['rt']['uri'], CONFIG['rt']['user'], CONFIG['rt']['password'])

logger = utils.log('intelmqcli', log_level=CONFIG['log_level'])

QUERY_COUNT_ASN = """
SELECT
    COUNT(*) as count,
    {conttab}.contacts,
    string_agg(DISTINCT cast({evtab}."source.asn" as varchar), ', ') as asn,
    string_agg(DISTINCT {evtab}."classification.type", ', ') as classification
FROM {evtab}
LEFT OUTER JOIN as_contacts ON {evtab}."source.asn" = {conttab}.asnum
WHERE
    notify = TRUE AND
    {evtab}.rtir_report_id IS NULL AND
    {evtab}.rtir_incident_id IS NULL AND
    {evtab}.rtir_investigation_id IS NULL AND
    (
        {evtab}."source.geolocation.cc" LIKE '{cc}' OR
        {evtab}."source.fqdn" LIKE '{fqdn}'
    )
GROUP BY {conttab}.contacts;
""".format(evtab=DBTABLE, cc=CONFIG['filter']['cc'],
           fqdn=CONFIG['filter']['fqdn'],
           conttab=CONFIG['database']['contacts_table'])
QUERY_BY_ASCONTACT = """
SELECT
    {evtab}.id,
    to_char({evtab}."time.source" at time zone 'UTC',
            'YYYY-MM-DD"T"HH24:MI:SSOF') as "time.source",
    {evtab}."source.ip",
    {evtab}."source.reverse_dns",
    {evtab}."source.fqdn",
    {evtab}."source.asn",
    {evtab}."source.url",
    {evtab}."feed.name",
    {evtab}."classification.type"
FROM events
LEFT OUTER JOIN {conttab} ON {evtab}."source.asn" = {conttab}.asnum
WHERE
    notify = TRUE AND
    {evtab}.rtir_report_id IS NULL AND
    {evtab}.rtir_incident_id IS NULL AND
    {evtab}.rtir_investigation_id IS NULL AND
    {conttab}.contacts = '{{}}';
""".format(evtab=DBTABLE,
           conttab=CONFIG['database']['contacts_table'])
QUERY_SET_RTIRID = """
UPDATE events SET
    rtir_{type}_id = {rtirid}
WHERE
    id = ANY('{{{ids}}}'::int[]);
"""


def query_by_ascontact(ascontact, show_table=False, requestor=None):
    # TODO: show_table
    if requestor is None:
        requestor = ascontact

    CUR.execute(QUERY_BY_ASCONTACT.format(ascontact))
    query = CUR.fetchall()
    ids = list(str(row['id']) for row in query)

    subject = ('{date}: {count} incidents for your AS'
               ''.format(count=len(query),
                         date=datetime.datetime.now().strftime('%Y-%m-%d')))
    text = 'TODO: text'
    csvfile = io.StringIO()
    writer = csv.DictWriter(csvfile, fieldnames=sorted(query[0].keys()),
                            lineterminator='\n')
    writer.writeheader()
    writer.writerows(query)
    attachment_text = csvfile.getvalue()

    print('='*100)
    print(bold('To: {to}'.format(to=requestor)))
    print('Subject: {subj}'.format(subj=subject))
    print()
    print(text)
    print()
    if show_table:
        csvfile.seek(0)
        print(prettytable.from_csv(csvfile))
    else:
        print(attachment_text)
    print('-'*100)
    answer = input(inverted('(b)ack, (s)end, show (t)able, change (r)equestor '
                            'or (q)uit? ')).strip()
    if answer == 'q':
        exit(0)
    elif answer == 'b':
        return
    elif answer == 't':
        query_by_ascontact(ascontact, show_table=True, requestor=requestor)
        return
    elif answer.startswith('r'):
        if len(answer) == 1:
            requestor = ascontact
        elif answer[1:].strip().startswith('+'):
            requestor = requestor+','+answer[1:].strip()[1:]
        elif answer[1:].strip().startswith('-'):
            requestor = requestor.replace(answer[1:].strip()[1:], '')
        else:
            requestor = answer[1:].strip()
        query_by_ascontact(ascontact, requestor=requestor.strip(','))
        return
    elif answer != 's':
        print(red('Unknow command {!r}.'.format(answer)))
        query_by_ascontact(ascontact, requestor=requestor)
        return

    report_id = RT.create_ticket(Queue='Incident Reports', Subject=subject,
                                 Requestors=requestor)
    if report_id == -1:
        logger.error(red('Could not create Incident Report.'))
        return
    logger.info(green('Created Incident Report {}.'.format(report_id)))
    CUR.execute(QUERY_SET_RTIRID.format(ids=','.join(ids), rtirid=report_id,
                                        type='report'))
    attachment = io.BytesIO()
    ziphandle = zipfile.ZipFile(attachment, mode='w')
    ziphandle.writestr('events.csv', attachment_text)
    ziphandle.close()
    attachment.seek(0)
    response = RT.comment(report_id, files=[('events.zip', attachment)])
    if not response:
        logger.exception(red('Could not attach file.'))
        return

    incident_id = RT.create_ticket(Queue='Incidents', Subject=subject)
    if incident_id == -1:
        logger.error(red('Could not create Incident.'))
        return
    logger.info(green('Created Incident {}.'.format(incident_id)))
    if not RT.edit_link(report_id, 'MemberOf', incident_id):
        logger.error(red('Could not link Incident to Incident Report.'))
        return
    CUR.execute(QUERY_SET_RTIRID.format(ids=','.join(ids), rtirid=incident_id,
                                        type='incident'))
    investigation_id = RT.create_ticket(Queue='Investigations',
                                        Subject=subject)
    if investigation_id == -1:
        logger.error(red('Could not create Investigation.'))
        return
    logger.info(green('Created Investigation {}.'.format(investigation_id)))
    if not RT.edit_link(incident_id, 'HasMember', investigation_id):
        logger.error(red('Could not link Investigation to Incident.'))
        return
    if not RT.edit_ticket(incident_id, Status='resolved'):
        logger.error('Could not close incident {}.'.format(incident_id))


def count_by_asn():
    # TODO: Existing RT ids!
    CUR.execute(QUERY_COUNT_ASN)
    asn_count = CUR.fetchall()
    max_asn_length = max([len(row['asn']) for row in asn_count])
    max_contact_length = max([len(row['contacts']) for row in asn_count])
    print('='*100)
    print(bold("{id:>3} {count:3} {asn!s: <{asnlen}} {contacts!s: <{conlen}} "
               "{type!s}".format(id='id', count='nÂ°', asn='ASNs', type='types',
                                 conlen=max_contact_length,
                                 asnlen=max_asn_length, contacts='contacts')))
    for number, row in enumerate(asn_count):
        print("{id:>3} {count:3} {asn!s: <{asnlen}} {contacts!s: <{conlen}} "
              "{type!s}".format(count=row['count'], asn=row['asn'],
                                asnlen=max_asn_length, id=number,
                                contacts=row['contacts'],
                                conlen=max_contact_length,
                                type=row['classification']))
    print('{} incidents for {} contacts.'
          ''.format(sum((row['count'] for row in asn_count)), len(asn_count)))
    return asn_count

if __name__ == '__main__':
    if not RT.login():
        logger.error(red('Could not login to RT.'))
    try:
        while True:
            asn_count = count_by_asn()
            answer = input(inverted('detailed view by id, (a)utomatic '
                                    'sending, (q)uit? ')).strip()
            try:
                answer = int(answer)
            except ValueError:
                pass
            if answer == 'q':
                break
            elif answer == 'a':
                raise NotImplementedError
                for count, contacts, asn, classtype in asn_count:
                    query_by_ascontact(contacts)
            elif type(answer) is int:
                query_by_ascontact(asn_count[answer]['contacts'])

    except Exception as exc:
        if not isinstance(exc, SystemExit):
            logger.exception('')
    finally:
        RT.logout()
